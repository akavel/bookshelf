module com.akavel.bookshelf.layout;

import android.content.Context;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import android.util.Log;
import android.view.Gravity;
import android.view.View;
import android.view.View$MeasureSpec;
import android.view.ViewGroup;
import android.view.ViewGroup$LayoutParams;
import android.view.ViewGroup$MarginLayoutParams;
import android.widget.RemoteViews;
import android.graphics.Rect;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.GravityCompat;

load com.akavel.utils;

combineMeasuredStates curState newState = curState b_or newState;

positionMiddle = 0;
positionLeft = 1;
positionRight = 2;

//demode measureSpec = View$MeasureSpec#toString(measureSpec);
//	//(
//	//m = View$MeasureSpec#getMode(measureSpec);
//	//s = View$MeasureSpec#getSize(measureSpec);
demode measureSpec = case View$MeasureSpec#getMode(measureSpec) of
	View$MeasureSpec#AT_MOST: AtMost View$MeasureSpec#getSize(measureSpec);
	View$MeasureSpec#EXACTLY: Exactly View$MeasureSpec#getSize(measureSpec);
	_: Unspecified ()
	esac;

typedef shyness = Greedy () | Fixed () | Shy ();

class MainLayout$LayoutParams(yeti.lang.Tag t) extends ViewGroup$LayoutParams(ViewGroup$LayoutParams#FILL_PARENT, 0)
	yeti.lang.Tag getTag() t;
end;

mainLayoutParams shy is shyness -> ~ViewGroup$LayoutParams =
	new MainLayout$LayoutParams(shy as ~yeti.lang.Tag);
shynessFromLayoutParams p is ~ViewGroup$LayoutParams -> shyness =
	(p unsafely_as ~MainLayout$LayoutParams)#getTag() unsafely_as shyness;

children g is ~ViewGroup -> list<~View> = (
	next i = if i >= g#getChildCount() then []
		else g#getChildAt(i) :. \(next (i + 1)) fi;
	next 0);

class MainLayout(Context context, AttributeSet attrs) extends ViewGroup(context, attrs)

	// Ask all children to measure themselves and compute the measurement of this
	// layout based on the children.
	void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
		count = this#getChildCount(); //TODO: use `children ()`
		log.d "MainLayout" "onMeasure, #children=\(count) w=\(demode widthMeasureSpec) h=\(demode heightMeasureSpec)";
		
		//TODO: handle widthMeasureSpec
		
		for [0 .. count - 1] do i:
			child = this#getChildAt(i);
			log.d "MainLayout" " child \(i)";
			if child#getVisibility() != ViewGroup#GONE then //TODO: use std lib `filter` or something similar
				
			fi
		done;
		
		//// Check against our minimum height and width
		//maxHeight := max maxHeight this#getSuggestedMinimumHeight();
		//maxWidth := max maxWidth this#getSuggestedMinimumWidth();
		//
		//// Report our final dimensions.
		//this#setMeasuredDimension(
		//	ViewCompat#resolveSizeAndState(maxWidth, widthMeasureSpec, childState),
		//	ViewCompat#resolveSizeAndState(maxHeight, heightMeasureSpec,
		//		childState shl ViewCompat#MEASURED_HEIGHT_STATE_SHIFT))
		(),
end;

//class CustomLayout$LayoutParams(Context c, AttributeSet attrs) extends ViewGroup$MarginLayoutParams(c, attrs)
class CustomLayout$LayoutParams(int w, int h) extends ViewGroup$MarginLayoutParams(w, h)
	var gravity = Gravity#TOP b_or GravityCompat#START,
	var position = positionMiddle,
	
	int getGravity() gravity,
	void setGravity(int g) gravity := g,
	int getPosition() position,
	void setPosition(int p) position := p,
end;

class CustomLayout(Context context, AttributeSet attrs) extends ViewGroup(context, attrs)
	// The amount of space used by children in the left/right gutter.
	var leftWidth = 0,
	var rightWidth = 0,
	
	// Ask all children to measure themselves and compute the measurement of this
	// layout based on the children.
	void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
		log.d "CustomLayout" "onMeasure, #children=\(this#getChildCount()) w=\(demode widthMeasureSpec) h=\(demode heightMeasureSpec)";
		
		// These keep track of the space we are using on the left and right for
		// views positioned there; we need member variables so we can also use
		// these for layout later.
		leftWidth := 0;
		rightWidth := 0;
		
		// Measurement will ultimately be computing these values.
		var maxHeight = 0;
		var maxWidth = 0;
		var childState = 0;
		
		// Iterate through all children, measuring them and computing our dimensions
		// from their size.
		for (children this) do child:
			log.d "CustomLayout" " child";
			if child#getVisibility() != ViewGroup#GONE then
				child#measure(View$MeasureSpec#UNSPECIFIED, View$MeasureSpec#UNSPECIFIED);
				_ = Log#d("CustomLayout", "  unspec: \(child#getMeasuredWidth())x\(child#getMeasuredHeight())");
			
				// Measure the child.
				this#measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
				_ = Log#d("CustomLayout", "  w/marg: \(child#getMeasuredWidth())x\(child#getMeasuredHeight())");
				
				// Update our size information based on the layout params.  Children
				// that asked to be positioned on the left or right go in those gutters.
				lp = child#getLayoutParams() unsafely_as ~CustomLayout$LayoutParams;
				dw = max maxWidth (child#getMeasuredWidth() + lp#leftMargin + lp#rightMargin);	
				if lp#getPosition() == positionLeft then
					leftWidth := leftWidth + dw
				elif lp#getPosition() == positionRight then
					rightWidth := rightWidth + dw
				else
					maxWidth := maxWidth + dw
				fi;
				maxHeight := max maxHeight (child#getMeasuredHeight() + lp#topMargin + lp#bottomMargin);
				childState := combineMeasuredStates childState ViewCompat#getMeasuredState(child)
			fi
		done;
		
		// Total width is the maximum width of all inner children plus the gutters.
		maxWidth := maxWidth + leftWidth + rightWidth;
		
		// Check against our minimum height and width
		maxHeight := max maxHeight this#getSuggestedMinimumHeight();
		maxWidth := max maxWidth this#getSuggestedMinimumWidth();
		
		// Report our final dimensions.
		this#setMeasuredDimension(
			ViewCompat#resolveSizeAndState(maxWidth, widthMeasureSpec, childState),
			ViewCompat#resolveSizeAndState(maxHeight, heightMeasureSpec,
				childState shl ViewCompat#MEASURED_HEIGHT_STATE_SHIFT)),
	
	// Position all children within this layout.
	void onLayout(boolean changed, int left, int top, int right, int bottom)
		count = this#getChildCount();
		
		// These are the far left and right edges in which we are performing layout.
		var leftPos = this#getPaddingLeft();
		var rightPos = right - left - this#getPaddingRight();

		// This is the middle region inside of the gutter.
		middleLeft = leftPos + leftWidth;
		middleRight = rightPos - rightWidth;

		// These are the top and bottom edges in which we are performing layout.
		parentTop = this#getPaddingTop();
		parentBottom = bottom - top - this#getPaddingBottom();

		var tmpContainerRect = new Rect();
		var tmpChildRect = new Rect();
		for [0 .. count-1] do i:
			child = this#getChildAt(i);
			if child#getVisibility() != ViewGroup#GONE then
				lp = child#getLayoutParams() unsafely_as ~CustomLayout$LayoutParams;

				width = child#getMeasuredWidth();
				height = child#getMeasuredHeight();

				// Compute the frame in which we are placing this child.
				if lp#getPosition() == positionLeft then
					tmpContainerRect#left := leftPos + lp#leftMargin;
					tmpContainerRect#right := leftPos + width + lp#rightMargin;
					leftPos := tmpContainerRect#right
				elif lp#getPosition() == positionRight then
					tmpContainerRect#right := rightPos - lp#rightMargin;
					tmpContainerRect#left := rightPos - width - lp#leftMargin;
					rightPos := tmpContainerRect#left
				else
					tmpContainerRect#left := middleLeft + lp#leftMargin;
					tmpContainerRect#right := middleRight - lp#rightMargin
				fi;
				tmpContainerRect#top := parentTop + lp#topMargin;
				tmpContainerRect#bottom := parentBottom - lp#bottomMargin;

				// Use the child's gravity and size to determine its final
				// frame within its container.
				Gravity#apply(lp#getGravity(), width, height, tmpContainerRect, tmpChildRect);

				// Place the child.
				child#layout(tmpChildRect#left, tmpChildRect#top,
					tmpChildRect#right, tmpChildRect#bottom)
            fi
        done,
		
	
end;

{ mainLayoutParams, shynessFromLayoutParams }
